window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "photonbend", "modulename": "photonbend", "type": "module", "doc": "<h1 id=\"intro\">Intro</h1>\n\n<p>Photonbend is a python module to handle photos, especially photos taken with\nfisheye lenses, and convert them between different kinds of lenses, FoV, and\ntypes of photos like inscribed circles, cropped circles, or even\nside-by-side double inscribed circles. It also allows you to rotate those\nphotos, convert them to equirectangular panoramas or convert panoramas to\nfisheye photos.</p>\n\n<p>It can be used as a library to handle images on your projects or it can be\nused as a standalone tool with its own set of commands to help you alter\nyour photos taken with a fisheye lens, an omnidirectional camera such as the\nSamsung Gear 360 or an equirectangular panorama.</p>\n\n<p>If you just want to use the tools go to the Scripts. If you want to\nunderstand how it works just keep reading.</p>\n\n<h1 id=\"how-it-works\">How it works</h1>\n\n<p>This module uses the information you provide about the image format, lenses,\nand FoV, couples it with mathematical functions that describes the ways the\nlenses behave, and makes use of trigonometry to map the pixels of your planar\nphotos or panoramas to angles producing a sphere-like mappings.</p>\n\n<p>Using a sphere as a base lets you rotate the image. It provides lens functions\nand and objects that let you re-take a picture from another one, using different\nlenses and FoV to produce new images. It also lets you map the camera images\nto an equirectangular panorama.</p>\n"}, {"fullname": "photonbend.core", "modulename": "photonbend.core", "type": "module", "doc": "<p>This module is the main part of photonbend. Within its submodules it gathers the tools\nneeded to process camera-based images and panoramas.</p>\n\n<p>In order to execute at reasonable speeds, the numpy library is used heavily on this\nmodule.</p>\n\n<h1 id=\"terminology\">Terminology</h1>\n\n<p>Some basic definitions needed to be able to use photonbend's functionality properly.</p>\n\n<h2 id=\"image\">Image</h2>\n\n<p>An image is, for the intends and purposes of this module, a numpy array of uint8 with\nshape (height, width, channels). Channels is <strong>always</strong> equal to number 3, and it stands\nfor the pixels channels, the colors <strong>Red, Green and Blue</strong>.</p>\n\n<pre><code># Making a new black image of width 1000 and height 600 using numpy\nimport numpy as np\nblack_image = np.zeros((600, 1000, 3), np.uint8)\n</code></pre>\n\n<h2 id=\"coordinate-map\">Coordinate Map</h2>\n\n<p>A coordinate map is a numpy array of float64 with shape (height, width, sub-elements).\nThe sub-elements value <strong>always</strong> equals to 3, representing the Latitude, Longitude and\na Invalid pixel marker.</p>\n\n<ul>\n<li>Latitude is represented in radians from 0 to Pi radians.</li>\n<li>Longitude is represented in radians from 0 to 2*Pi radians.</li>\n<li>Invalid is a marker. Any pixel which has an invalid value not equal to 0 should be\nconsidered invalid.</li>\n</ul>\n\n<h2 id=\"the-projectionimage-protocol\">The ProjectionImage Protocol</h2>\n\n<p>The protocol used by photonbend to allow the interchange between image mappings (camera\nbased images and panoramas).</p>\n\n<p>It is composed of only 2 methods and an instance variable:</p>\n\n<ul>\n<li>instance variable\n<ul>\n<li>image: A numpy array of shape (height, width, channels) where channels is always\n3 as it is an RGB image in array form.</li>\n</ul></li>\n<li>methods\n<ul>\n<li>get_coordinate_map(): Should return the coordinate map of it's object/image.</li>\n<li>process_coordinate_map(coordinate_map): Should use each pixel of the received\ncoordinate_map, translating its coordinate data to this object's image data as\nreferenced by this object own coordinate mapping function, returning this mapped\nimage.</li>\n</ul></li>\n</ul>\n\n<h3 id=\"example-on-how-to-use-the-projection-protocol\">Example on how to use the Projection Protocol</h3>\n\n<pre><code># You may use PIL or Pillow to save the final image\nfrom PIL import image\n\n...\n\n# Create the source and destiny projections\nsource_projection: ProjectionImage = AProjectionClass(*source_parameters)\ndestiny_projection: ProjectionImage = AnotherProjectionClass(*destiny_parameters)\n\n# Get the coordinate map for the destiny projection\ndestiny_coordinate_map = destiny_projection.get_coordinate_map()\n\n# Get the source image mapped to the destiny coordinates an RGB image as a numpy array\ndestiny_image_arr = source_projection.process_coordinate_map(destiny_coordinate_map)\n\n# Now you can save the destiny image to a file\ndestiny_image = Image.fromarray(destiny_image_arr)\ndestiny_image.save(\"Destiny.jpg\")\n\n# Or you put it on the destiny_projection for some other use\ndestiny_projection.image = destiny_image_arr\n\n...\n\n</code></pre>\n"}, {"fullname": "photonbend.core.lens", "modulename": "photonbend.core.lens", "type": "module", "doc": "<p>This module has the <strong>Lens</strong> class and the implementation for some of the\nlens functions and reverse lens functions.</p>\n\n<p>It provides many Lenses models which are usually used with\nphotonbend.core.projection.CameraImage instances.</p>\n\n<p>For static analysis purposes, it defines the <strong>UniFloat</strong> type.\nFor all intents and purposes, this type means either <strong>float</strong> or\n<strong>npt.NDArray[np.float64]</strong>, but only one of them per function call.</p>\n\n<p>That means all lens functions:</p>\n\n<ul>\n<li>Return a <em>float</em> when given one.</li>\n<li>Return a <em>npt.NDArray[float]</em> when given one.</li>\n</ul>\n"}, {"fullname": "photonbend.core.lens.Lens", "modulename": "photonbend.core.lens", "qualname": "Lens", "type": "class", "doc": "<p>Represents a lens with both forward and reverse functions.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>forward_function (Callable[[UniFloat], UniFloat]):</strong>  A function that given\nan incidence angle in radians gives back a distance from the\nprojection center in focal distance units.\nIt must handle either a single float or an array of floats.</li>\n<li><strong>reverse_function (Callable[[UniFloat], UniFloat]):</strong>  A function that\ngiven an distance from the projection center in focal\ndistance units back the incidence angle in radians.\nIt must handle either a single float or an array of floats.</li>\n</ul>\n"}, {"fullname": "photonbend.core.lens.Lens.__init__", "modulename": "photonbend.core.lens", "qualname": "Lens.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">forward_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">UniFloat</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">UniFloat</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">reverse_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">UniFloat</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">UniFloat</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "photonbend.core.lens.equisolid", "modulename": "photonbend.core.lens", "qualname": "equisolid", "type": "function", "doc": "<p>Returns an equisolid lens.</p>\n\n<p>It's functions are:</p>\n\n<ul>\n<li>$f(\\theta) = 2 \\times \\sin(\\frac{\\theta}{2})$</li>\n<li>$f(projection) = 2 \\times \\arcsin(\\frac{projection}{2})$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.lens.equidistant", "modulename": "photonbend.core.lens", "qualname": "equidistant", "type": "function", "doc": "<p>Returns an equidistant lens.</p>\n\n<p>It's functions are:</p>\n\n<ul>\n<li>$f(\\theta) = \\theta$</li>\n<li>$f(projection) = projection$</li>\n</ul>\n\n<p>Both are a simple identity function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.lens.rectilinear", "modulename": "photonbend.core.lens", "qualname": "rectilinear", "type": "function", "doc": "<p>Returns a rectilinear lens.</p>\n\n<p>It's functions are:</p>\n\n<ul>\n<li>$f(\\theta) = \\tan(\\theta)$</li>\n<li>$f(projection) = \\arctan(projection)$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.lens.stereographic", "modulename": "photonbend.core.lens", "qualname": "stereographic", "type": "function", "doc": "<p>Returns a stereographic lens</p>\n\n<p>It's functions are:</p>\n\n<ul>\n<li>$f(\\theta) = 2 \\times \\tan(\\frac{\\theta}{2})$</li>\n<li>$f(projection) = 2\\times \\arctan(\\frac{projection}{2})$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.lens.orthographic", "modulename": "photonbend.core.lens", "qualname": "orthographic", "type": "function", "doc": "<p>Returns an orthographic lens.</p>\n\n<p>It's functions are:</p>\n\n<ul>\n<li>$f(\\theta) = \\sin(\\theta)$</li>\n<li>$f(projection) = \\arcsin(projection)$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.lens.thoby", "modulename": "photonbend.core.lens", "qualname": "thoby", "type": "function", "doc": "<p>Returns a thoby lens.\nIt's functions are:</p>\n\n<ul>\n<li><p>$f(\\theta) = 1.47 \\times \\sin(0.713 \\times \\theta)$</p></li>\n<li><p>$f(projection) = \\frac{\\arcsin(\\frac{projection}{1.47})}{0.713}$</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection", "modulename": "photonbend.core.projection", "type": "module", "doc": "<p>This module provides the classes and methods that allow you to map pixels to angles and\nvice-versa. It allows you to convert between different sort of images through its\nclasses.</p>\n"}, {"fullname": "photonbend.core.projection.ProjectionImage", "modulename": "photonbend.core.projection", "qualname": "ProjectionImage", "type": "class", "doc": "<p>Defines the protocol used by all projection images.</p>\n", "bases": "typing.Protocol"}, {"fullname": "photonbend.core.projection.ProjectionImage.get_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "ProjectionImage.get_coordinate_map", "type": "function", "doc": "<p>Should return this image coordinate map.</p>\n\n<p>Returns a coordinate map for this image based on its structure</p>\n\n<p><em>For more information on coordinate maps check the documentation\nfor the photonbend.core module.</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.ProjectionImage.process_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "ProjectionImage.process_coordinate_map", "type": "function", "doc": "<p>Should map the image based on the received coordinate map.</p>\n\n<p>Returns a image by mapping this image's pixels to the received coordinate map\nbased on its coordinates and its own mapping.</p>\n\n<p><em>For more information on coordinate maps check the documentation\nfor the photonbend.core module.</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.CameraImage", "modulename": "photonbend.core.projection", "qualname": "CameraImage", "type": "class", "doc": "<p>Store and process camera-based images and their coordinates.</p>\n\n<p>This class maps each pixel of an image to a geodesic-like coordinate of the form\n(latitude, longitude) based on its attributes.\nIt can handle images that follow the principles of camera-based imagery.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>image (np.ndarray[int8]):</strong>  The image as a numpy array with the shape\n(height, width, 3).</li>\n<li><strong>fov (float):</strong>  The image Field of View in radians.</li>\n<li><strong>lens (Lens):</strong>  This image's lens instance.</li>\n<li><strong>magnitude (float):</strong>  The distance in pixels from the center of the image\nwhere the maximum FoV is reached.</li>\n<li><strong>f_distance (float):</strong>  The focal distance of this image in pixels.</li>\n</ul>\n", "bases": "ProjectionImage"}, {"fullname": "photonbend.core.projection.CameraImage.__init__", "modulename": "photonbend.core.projection", "qualname": "CameraImage.__init__", "type": "function", "doc": "<p>Initializes instance attributes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image_arr (numpy.ndarray):</strong>  A numpy array of int8 representing an RGB\nimage. The image follows the shape (height, width, 3).</li>\n<li><strong>fov (float):</strong>  Thehe Field of View in radians.</li>\n<li><strong>lens (Lens):</strong>  A lens with its forward and reverse functions.</li>\n<li><p><strong>magnitude (float):</strong>  The distance in pixels from the center of the\nimage where the maximum FoV is reached.\nFor the default case of an inscribed circle image, this value is\ncalculated automatically, therefore it should only be used when\npassing an image that is not an inscribed circle.</p>\n\n<p><strong>Examples:</strong></p>\n\n<ul>\n<li>For the inscribed image, it is the image width or\n   height divided by 2.</li>\n<li>For the full canvas image, it is the distance in\n   pixels of the image center to one of its\n   corners.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">fov</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">lens</span><span class=\"p\">:</span> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>,</span><span class=\"param\">\t<span class=\"n\">magnitude</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "photonbend.core.projection.CameraImage.get_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "CameraImage.get_coordinate_map", "type": "function", "doc": "<p>Returns this image coordinate map.</p>\n\n<p>Returns a coordinate map for this image based on its size, fov, lens\nfunction and magnitude.</p>\n\n<p><em>For more information on coordinate maps check the documentation\nfor the photonbend.core module.</em></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy array of float64 as a coordinate map.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.CameraImage.process_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "CameraImage.process_coordinate_map", "type": "function", "doc": "<p>Produces a new image based on a coordinate map.</p>\n\n<p>Process a given coordinate map and maps each of its coordinates to a\npixel on this instance image, producing a new image.</p>\n\n<p><em>For more information on coordinate maps, check the documentation\nfor the photonbend.core module.</em></p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coordinate_map (np.ndarray[np.float64]):</strong>  A coordinate map.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A new image based on the pixel data of this instance and the given\n      coordinate map.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.DoubleCameraImage", "modulename": "photonbend.core.projection", "qualname": "DoubleCameraImage", "type": "class", "doc": "<p>Store and process 360 degrees camera-based images and their coordinates.</p>\n\n<p>This class maps each pixel of an image to a geodesic-like coordinate of the form\n(latitude, longitude) based on its attributes.\nIt can handle images that follow the principles of 360 degrees cameras, which\nstore the two images captured by its 2 opposite sensors, side-by-side on a\nsingle image file.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>image (np.ndarray[int8]):</strong>  The image as a numpy array with the shape\n(height, width, 3).</li>\n<li><strong>fov (float):</strong>  The image Field of View in radians for each sensor.</li>\n<li><strong>lens (Lens):</strong>  This image's lens instance.</li>\n<li><strong>magnitude (float):</strong>  The distance in pixels from the center of the image\nwhere the maximum FoV is reached.</li>\n<li><strong>f_distance (float):</strong>  The focal distance of this image in pixels.</li>\n</ul>\n", "bases": "ProjectionImage"}, {"fullname": "photonbend.core.projection.DoubleCameraImage.__init__", "modulename": "photonbend.core.projection", "qualname": "DoubleCameraImage.__init__", "type": "function", "doc": "<p>Initializes instance attributes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image_arr (np.ndarray):</strong>  A numpy array of int8 representing an RGB\nimage. The image follows the shape (height, width, 3).</li>\n<li><strong>sensor_fov (float):</strong>  The Field of View in radians of a single\nsensor. Since 360 degrees cameras normally use 2 equal sensors\nin opposite directions, the software needs to know the FoV used\nby them.</li>\n<li><strong>lens (Lens):</strong>  A lens with its forward and reverse functions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">sensor_fov</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">lens</span><span class=\"p\">:</span> <span class=\"n\">photonbend</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">lens</span><span class=\"o\">.</span><span class=\"n\">Lens</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "photonbend.core.projection.DoubleCameraImage.get_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "DoubleCameraImage.get_coordinate_map", "type": "function", "doc": "<p>Returns this image coordinate map.</p>\n\n<p>Returns a coordinate map for this image based on its size, fov, lens\nfunction and magnitude.</p>\n\n<p><em>For more information on coordinate maps check the documentation\nfor the photonbend.core module.</em></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy array of float64 as a coordinate map.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.DoubleCameraImage.process_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "DoubleCameraImage.process_coordinate_map", "type": "function", "doc": "<p>Should map the image based on the received coordinate map.</p>\n\n<p>Returns a image by mapping this image's pixels to the received coordinate map\nbased on its coordinates and its own mapping.</p>\n\n<p><em>For more information on coordinate maps check the documentation\nfor the photonbend.core module.</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.PanoramaImage", "modulename": "photonbend.core.projection", "qualname": "PanoramaImage", "type": "class", "doc": "<p>Store and process equirectangular panorama images and their coordinates.</p>\n\n<p>This class maps each pixel of an image to a polar coordinates of the form\n(latitude, longitude) based on its size. It can handle equirectangular\npanoramas (images with a 2:1 width to height ration).</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>image (np.ndarray[int]):</strong>  The image as an array of shape\n(height, width, 3).</li>\n</ul>\n", "bases": "ProjectionImage"}, {"fullname": "photonbend.core.projection.PanoramaImage.__init__", "modulename": "photonbend.core.projection", "qualname": "PanoramaImage.__init__", "type": "function", "doc": "<p>Initializes instance attributes</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image_arr (np.ndarray):</strong>  A numpy ndarray of shape (height, width, 3),\nwhere height is equal to half the width.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span>)</span>"}, {"fullname": "photonbend.core.projection.PanoramaImage.get_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "PanoramaImage.get_coordinate_map", "type": "function", "doc": "<p>Returns this image coordinate map.</p>\n\n<p>Returns a coordinate map for this image based solely on its  dimensions.</p>\n\n<p><em>For more information on coordinate maps check the documentation for the\nphotonbend.core module.</em></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy ndarray of float64 as a coordinate map.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.PanoramaImage.process_coordinate_map", "modulename": "photonbend.core.projection", "qualname": "PanoramaImage.process_coordinate_map", "type": "function", "doc": "<p>Produces a new image based on a coordinate maps.</p>\n\n<p>Process a given coordinate map and maps each of its coordinates  to a\npixel on this instance image, producing a new image.</p>\n\n<p><em>For more information on coordinate maps, check the documentation for\nthe photonbend.core module.</em></p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coordinate_map (np.ndarray):</strong>  A numpy array of float64 as a\ncoordinate map.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A new image (ndarray) based on the pixel data of this instance and\n  the given coordinate map.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.projection.map_projection", "modulename": "photonbend.core.projection", "qualname": "map_projection", "type": "function", "doc": "<p>Converts a coordinate map to a color map.</p>\n\n<p>A simple visualization method that allows one to converts a coordinate map to to a\nRGB color map so that we can see the projection.</p>\n\n<p>Latitude gets translated to <strong>red</strong>, Longitude to <strong>green</strong> and invalid area mapping\ngets translated to <strong>blue</strong>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.core.rotation", "modulename": "photonbend.core.rotation", "type": "module", "doc": "<p></p>\n"}, {"fullname": "photonbend.core.rotation.Rotation", "modulename": "photonbend.core.rotation", "qualname": "Rotation", "type": "class", "doc": "<p>Represents a rotation, allowing it to be applied to coordinate maps.</p>\n\n<p>The intended usage of this class is to being created with rotation\nparameters, and use the method rotate_coordinate_map to rotate the maps\ngenerated by classes that follow the ProjectionImage protocol\n(photonbend.core.projection.ProjectionImage).</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>pitch (float):</strong>  rotation measured in radians in the pitch axis.</li>\n<li><strong>yaw (float):</strong>  rotation measured in radians in the yaw axis.</li>\n<li><strong>roll (float):</strong>  rotation measured in radians in the roll axis.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Rotate an image using a rotation and a coordinate map:</p>\n\n<pre><code># Get a coordinate map\ncoordinate_map = a_projection_image.get_coordinate_map()\n# Creates a rotation and uses it to rotate a coordinate map\nrotation = Rotation(np.pi/2, 0, 0)\nrotated_coordinate_map = rotation.rotate_coordinate_map(coordinate_map)\n# Get the rotated image array\nrotated_image = a_projection_image\n    .process_coordinate_map(rotated_coordinate_map)\n</code></pre>\n</blockquote>\n"}, {"fullname": "photonbend.core.rotation.Rotation.__init__", "modulename": "photonbend.core.rotation", "qualname": "Rotation.__init__", "type": "function", "doc": "<p>Initializes instance attributes</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pitch (float):</strong>  rotation measured in radians in the pitch axis.</li>\n<li><strong>yaw (float):</strong>  rotation measured in radians in the yaw axis.</li>\n<li><strong>roll (float):</strong>  rotation measured in radians in the roll axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pitch</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">yaw</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">roll</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "photonbend.core.rotation.Rotation.rotate_coordinate_map", "modulename": "photonbend.core.rotation", "qualname": "Rotation.rotate_coordinate_map", "type": "function", "doc": "<p>Rotates a coordinate map in the pitch, yaw, and roll axis.</p>\n\n<p>Rotates a coordinate map, producing a new coordinate map.</p>\n\n<p><em>For more info about coordinate maps check the documentation for\nthe photonbend.core module.</em></p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coordinate_map (np.ndarray):</strong>  A numpy array of float64.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The rotated coordinate map with the same shape as the input.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coordinate_map</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.scripts", "modulename": "photonbend.scripts", "type": "module", "doc": "<h1 id=\"scripts\">Scripts</h1>\n\n<p>When photonbend is installed, it sets up a script named photonbend with 3 different\ncommands to help you deal with your images.</p>\n\n<ul>\n<li><a href=\"#make-photo\">make-photo</a></li>\n<li><a href=\"#alter-photo\">alter-photo</a></li>\n<li><a href=\"#make-pano\">make-pano</a></li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>The commands have a common theme among them.\nParameters may have an <strong>\"i\"</strong> prefix or an <strong>\"o\"</strong> prefix. The former refer to\nparameters related to the input image. The latter refer to parameters related to the\noutput image. When a single version of the parameter is possible for the operation,\nthe prefix is omitted.</p>\n\n<ul>\n<li>--help: Provide some instructions on the command usage</li>\n<li>--lens (ilens|olens): Describe the desired lens used for the image.\n<ul>\n<li>equidistant</li>\n<li>equisolid</li>\n<li>orthographic</li>\n<li>rectilinear</li>\n<li>stereographic</li>\n</ul></li>\n<li>--type (itype|otype): Type of the image used or desired.\n<ul>\n<li>inscribed: The valid data is on a inscribed circle.</li>\n<li>double: The valid data is on two inscribed side-by-side circles.</li>\n<li>cropped: The valid data is on a inscribed circle, top-and-bottom cropped.</li>\n<li>full: The whole area of the image is valid data.</li>\n</ul></li>\n<li>--fov (ifov|ofov): The camera or sensor Field of View in degrees.</li>\n<li>--rotation: The rotation you want to apply in degrees on 3 axis of freedom.\n<ul>\n<li>pitch</li>\n<li>yaw</li>\n<li>roll</li>\n</ul></li>\n<li>--size: The vertical size of the destiny image. This is usually optional. The\nscript will select the same vertical height as the input image if omitted.</li>\n</ul>\n\n<h2 id=\"make-photo\">make-photo</h2>\n\n<p>This tool allows you to make a photo out of an equirectangular panorama (2:1 aspect\nration).</p>\n\n<h4 id=\"make-a-360-degrees-photo-with-an-equidistant-lens\">Make a 360 degrees photo with an equidistant lens</h4>\n\n<p>The example below creates a photo of type <code>inscribed</code>, with an <code>equidistant</code> lens,\nand an FoV of <code>360</code> degrees named <code>equidistant.jpg</code> from the panorama in the file\nnamed <code>panorama.jpg</code></p>\n\n<pre><code>photonbend make-photo --type inscribed --lens equidistant --fov 360 \\\npanorama.jpg\n</code></pre>\n\n<h2 id=\"alter-photo\">alter-photo</h2>\n\n<p>This tool allows you to change your photos by exchanging lenses, FoV, and types as\nwell as rotate your images.</p>\n\n<h4 id=\"change-of-projection-lens\">Change of projection (Lens)</h4>\n\n<p>The example below changes the photo lenses from <code>equidistant</code> projection to\n<code>equisolid</code> projection.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype inscribed --ilens equidistant \\\n--olens equisolid --ifov 360 --ofov 360 equidistant.jpg equisolid.jpg\n</code></pre>\n\n<h4 id=\"change-of-fov\">Change of FoV</h4>\n\n<p>The example below changes the photo <code>equidistant.jpg</code>. Its FoV is altered from <code>360</code>\ndegrees to <code>180</code>, producing the image <code>equidistant-180.jpg</code>.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype inscribed --ilens equidistant \\\n--olens equidistant --ifov 360 --ofov 180 equidistant.jpg equidistant-180.jpg\n</code></pre>\n\n<p><strong>Notice this is a very lossy operation. The new image will lose about half of its\n view data</strong></p>\n\n<h4 id=\"change-of-type\">Change of type</h4>\n\n<p>The example below changes the photo <code>equidistant.jpg</code>.\nIts type from <code>inscribed</code> to <code>double</code>, producing <code>equidistant-double.jpg</code>.</p>\n\n<p><strong>Note</strong>: When producing a <strong>double inscribed</strong> image, we <strong>nominally</strong> also have to\n<strong>change the FoV</strong>. That happens because the double inscribed image uses two\ninscribed images side by side on a single image file. Since double inscribed images\nare only meant to be used with full 360 degrees images, the FoV changes its meaning\nto describe the FoV of each sensor instead of the FoV of the whole image.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype double --ilens equidistant \\\n --olens equidistant --ifov 360 --ofov 195 equidistant.jpg equidistant-double.jpg\n</code></pre>\n\n<h4 id=\"change-of-type-lens-and-fov\">Change of type, lens, and FoV</h4>\n\n<p>The example below changes the photo <code>equidistant.jpg</code> from type <code>inscribed</code> to\n<code>full</code>, its lenses from <code>equidistant</code> to <code>rectilinear</code>, and its FoV from <code>360</code>\ndegrees to <code>140</code>, producing the image <code>rectlinear-full.jpg</code>.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype full --ilens equidistant \\\n--olens rectilinear --ifov 360 --ofov 140 equidistant.jpg rectlinear-full.jpg\n</code></pre>\n\n<h4 id=\"rotation\">Rotation</h4>\n\n<p>The example below changes the photo <code>equidistant.jpg</code>, rotating it <code>-90</code> degrees in\npitch, <code>0</code> degrees in yaw, and <code>0</code> degrees in roll, producing\n<code>equidistant-rotated.jpg</code>.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype inscribed --ilens equidistant \\\n--olens equidistant --ifov 360 --ofov 360 --rotation -90 0 0 equidistant.jpg \\\nequidistant-rotated.jpg\n</code></pre>\n\n<h4 id=\"combining-it-all\">Combining it all</h4>\n\n<p>The example below changes the photo <code>equidistant.jpg</code> from type <code>inscribed</code> to\n<code>full</code>, its lenses from <code>equidistant</code> to <code>rectilinear</code>, and its FoV from <code>360</code>\ndegrees to <code>140</code>. It is also rotated by <code>-90</code> degrees in pitch, <code>195</code> degrees in yaw\n and <code>0</code> degrees in roll producing the image <code>rectlinear-140-full-rotated.jpg</code>.</p>\n\n<pre><code>photonbend alter-photo --itype inscribed --otype full --ilens equidistant \\\n--olens rectilinear --ifov 360 --ofov 140 --rotation -90 0 195 equidistant.jpg \\\nrectlinear-140-full-rotated.jpg\n</code></pre>\n\n<h2 id=\"make-pano\">make-pano</h2>\n\n<p>This tool allows you to change create panoramas out of your photos</p>\n\n<h4 id=\"make-a-panorama\">Make a panorama</h4>\n\n<p>Make a panorama out of an <code>inscribed</code>, <code>equidistant</code> lens, <code>360</code> degrees FoV photo\nnamed <code>equidistant.jpg</code>, producing <code>panorama.jpg</code>.</p>\n\n<pre><code>photonbend make-pano --type inscribed --lens equidistant \\\n--fov 360 equidistant.jpg panorama.jpg\n</code></pre>\n\n<h4 id=\"make-a-rotated-panorama\">Make a rotated panorama</h4>\n\n<p>Make a panorama out of an <code>inscribed</code>, <code>equidistant</code> lens, <code>360</code> degrees FoV photo\nnamed <code>equidistant.jpg</code>, producing <code>panorama_rotated.jpg</code>.</p>\n\n<pre><code>photonbend make-pano --type inscribed --lens equidistant --fov 360 \\\n--rotation -90 0 90 equidistant.jpg panorama.jpg\n</code></pre>\n"}, {"fullname": "photonbend.utils", "modulename": "photonbend.utils", "type": "module", "doc": "<p>Some simple utility functions are available here.</p>\n"}, {"fullname": "photonbend.utils.to_radians", "modulename": "photonbend.utils", "qualname": "to_radians", "type": "function", "doc": "<p>Convert degrees to radians</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>degrees:</strong>  A float representing an angle in degrees</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A float representing the same angle in radians.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.utils.to_degrees", "modulename": "photonbend.utils", "qualname": "to_degrees", "type": "function", "doc": "<p>Convert radians to degrees</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radians:</strong>  A float representing an angle in radians</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A float representing the same angle in degrees.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radians</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "photonbend.utils.calculate_size_panorama_to_photo", "modulename": "photonbend.utils", "qualname": "calculate_size_panorama_to_photo", "type": "function", "doc": "<p>Computes the size for converting a panorama to a camera image.</p>\n\n<p>Uses the panorama dimensions and lens function to compute the necessary\nradius of of an inscribed photo in order to preserve the panorama\npixel information.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>panorama_size:</strong>  A tuple(int, int) storing respectively the\npanorama width and height in pixels.</li>\n<li><strong>lens_function:</strong>  A function that acts as the lens of a camera.</li>\n<li><strong>preserve_vertical_resolution:</strong>  A boolean that states whether this\nfunction should worry about preserving vertical resolution.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple containing the appropriate size (width, height) in\n  pixels for the conversion of the panorama to a photo-line image\n  for maintaining similar level of image detail.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">panorama_size</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lens_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">preserve_vertical_resolution</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();